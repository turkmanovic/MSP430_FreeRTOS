/**
 * @file    main.c
 * @author  Haris Turkmanovic(haris@etf.rs)
 * @date    2021
 * @brief   SRV Zadatak 21
 */

/* Standard includes. */
#include <stdio.h>
#include <stdlib.h>

/* FreeRTOS includes. */
#include "FreeRTOS.h"
#include "task.h"
#include "semphr.h"
#include "queue.h"
#include "event_groups.h"

/* Hardware includes. */
#include "msp430.h"

/* User's includes */
#include "../common/ETF5529_HAL/hal_ETF_5529.h"

/* Event bit definitions*/
#define  mainEVENT_BIT_BUTTON_S2    0x02    /* This is "Button S2 pressed" event bit mask */
#define  mainEVENT_BIT_BUTTON_S3    0x04    /* This is "Button S3 pressed" event bit mask */
#define  mainEVENT_BIT_BUTTON_S4    0x08    /* This is "Button S4 pressed" event bit mask */


/** "Display task" priority */
#define mainBUTTON_TASK_PRIO        ( 3 )
#define mainDIODE_TASK_PRIO         ( 1 )
#define mainUART_TASK_PRIO          ( 2 )

/* This semaphore will be used to signal "Button press" event*/
xSemaphoreHandle    xEvent_Button;
/* This is Event group which will be used to sync tasks in the software */
EventGroupHandle_t  xButtonEventsGroup;


static void prvSetupHardware( void );

/**
 * @brief "Diode Task" Function
 *
 * This task waits for Events "Button S3 Pressed" or "Button S4 pressed" in Event group.
 * After one of these events is generated by "Button Task" corresponding diode is changed
 */
static void prvDiodeTaskFunction( void *pvParameters )
{
    /* Value obtained from Event Group instance*/
    EventBits_t eventValue;
    for ( ;; )
    {
        /* Wait for "Button S3 Pressed" or "Button S4 pressed" event*/
        eventValue = xEventGroupWaitBits(xButtonEventsGroup,
                            mainEVENT_BIT_BUTTON_S3 | mainEVENT_BIT_BUTTON_S4,
                            pdTRUE,
                            pdFALSE,
                            portMAX_DELAY);
        /*Check what caused the exit from the blocked state*/
        if(eventValue & mainEVENT_BIT_BUTTON_S3){
            /* If exit is caused by "Button S3 Pressed" change LD3 diode state*/
            halTOGGLE_LED(LED3);
        }
        if(eventValue & mainEVENT_BIT_BUTTON_S4){
            /* If exit is caused by "Button S4 Pressed" change LD4 diode state*/
            halTOGGLE_LED(LED4);
        }
    }
}/**
 * @brief "UART Task" Function
 *
 * This task waits for Event "Button S2 Pressed" in Event group. After this events is generated
 * by "Button Task", string is sent over UART
 */
static void prvUARTTaskFunction( void *pvParameters )
{
    EventBits_t eventValue;
    char        string[]  = "Taster S2\r\n";
    char        *tmp;
    for ( ;; )
    {
        /* Value obtained from Event Group instance*/
        eventValue = xEventGroupWaitBits(xButtonEventsGroup,
                            mainEVENT_BIT_BUTTON_S2,
                            pdTRUE,
                            pdFALSE,
                            portMAX_DELAY);
        /*Checking what caused the exit from the blocked state is useless her
         *because this task waits for only one event. However we can still do
         *checking*/
        if(eventValue & mainEVENT_BIT_BUTTON_S2){
            tmp = string;
            while(*tmp != 0){
                while (!(UCA1IFG&UCTXIFG));
                UCA1TXBUF   =   *tmp;
                tmp        +=   1;
            }
        }
    }
}

/**
 * @brief "Button Task" Function
 *
 * This task waits for xEvent_Button semaphore to be given from
 * port ISR. After that, simple debbauncing is performed in order
 * to verify that button is still pressed. Depending on which key
 * is pressed, the corresponding bit is set in Event Group
 */
static void prvButtonTaskFunction( void *pvParameters )
{
    uint16_t i;
    /*Initial button states are 1 because of pull-up configuration*/
    uint8_t         currentButtonState  = 1;
    for ( ;; )
    {
        xSemaphoreTake(xEvent_Button,portMAX_DELAY);
        /*wait for a little to check that button is still pressed*/
        for(i = 0; i < 1000; i++);
        /*take button state*/
        /* check if button SW2 is pressed*/
        currentButtonState = ((P1IN & 0x02) >> 1);
        if(currentButtonState == 0){
            /* If SW2 is pressed set bit, defined with mainEVENT_BIT_BUTTON_S2 mask, in
             * Event Group */
            xEventGroupSetBits(xButtonEventsGroup, mainEVENT_BIT_BUTTON_S2);
            continue;
        }
        /* check if button SW3 is pressed*/
        currentButtonState = ((P1IN & 0x10) >> 4);
        if(currentButtonState == 0){
            /* If SW3 is pressed set bit, defined with mainEVENT_BIT_BUTTON_S3 mask, in
             * Event Group */
            xEventGroupSetBits(xButtonEventsGroup, mainEVENT_BIT_BUTTON_S3);
            continue;
        }
        /* check if button SW4 is pressed*/
        currentButtonState = ((P1IN & 0x20) >> 5);
        if(currentButtonState == 0){
            /* If SW4 is pressed set bit, defined with mainEVENT_BIT_BUTTON_S4 mask, in
             * Event Group */
            xEventGroupSetBits(xButtonEventsGroup, mainEVENT_BIT_BUTTON_S4);
            continue;
        }
    }
}
/**
 * @brief main function
 */
void main( void )
{
    /* Configure peripherals */
    prvSetupHardware();

    /* Create tasks */
    xTaskCreate( prvButtonTaskFunction,
                 "Button Task",
                 configMINIMAL_STACK_SIZE,
                 NULL,
                 mainBUTTON_TASK_PRIO,
                 NULL
               );
    xTaskCreate( prvDiodeTaskFunction,
                 "Diode Task",
                 configMINIMAL_STACK_SIZE,
                 NULL,
                 mainDIODE_TASK_PRIO,
                 NULL
               );
    xTaskCreate( prvUARTTaskFunction,
                 "UART Task",
                 configMINIMAL_STACK_SIZE,
                 NULL,
                 mainUART_TASK_PRIO,
                 NULL
               );
    /* Create FreeRTOS objects  */
    xButtonEventsGroup  = xEventGroupCreate();
    xEvent_Button       = xSemaphoreCreateBinary();
    /* Start the scheduler. */
    vTaskStartScheduler();

    /* If all is well then this line will never be reached.  If it is reached
    then it is likely that there was insufficient (FreeRTOS) heap memory space
    to create the idle task.  This may have been trapped by the malloc() failed
    hook function, if one is configured. */	
    for( ;; );
}

/**
 * @brief Configure hardware upon boot
 */
static void prvSetupHardware( void )
{
    taskDISABLE_INTERRUPTS();

    /* Disable the watchdog. */
    WDTCTL = WDTPW + WDTHOLD;

    hal430SetSystemClock( configCPU_CLOCK_HZ, configLFXT_CLOCK_HZ );

    /* - Init buttons - */
    /*Set direction to input*/
    P1DIR &= ~0x32;
    /*Enable pull-up resistor*/
    P1REN |= 0x32;
    P1OUT |= 0x32;
    /*Enable interrupt for pin connected to SW3*/
    P1IE  |= 0x32;
    P1IFG &=~0x32;
    /*Interrupt is generated during high to low transition*/
    P1IES |= 0x32;

    /* Initialize UART */
    P4SEL       |= BIT4+BIT5;                    // P4.4,5 = USCI_AA TXD/RXD
    UCA1CTL1    |= UCSWRST;                      // **Put state machine in reset**
    UCA1CTL1    |= UCSSEL_2;                     // SMCLK
    UCA1BRW      = 1041;                         // 1MHz - Baudrate 9600
    UCA1MCTL    |= UCBRS_6 + UCBRF_0;            // Modulation UCBRSx=1, UCBRFx=0
    UCA1CTL1    &= ~UCSWRST;                     // **Initialize USCI state machine**
    UCA1IE      |= UCRXIE;                       // Enable USCI_A1 RX interrupt

    /* initialize LEDs */
    vHALInitLED();
    /* initialize display*/
    vHAL7SEGInit();
    /*enable global interrupts*/
    taskENABLE_INTERRUPTS();
}
void __attribute__ ( ( interrupt( PORT1_VECTOR  ) ) ) vPORT1ISR( void )
{
    BaseType_t xHigherPriorityTaskWoken = pdFALSE;
    /* Give semaphore if button SW3 is pressed*/
    /* Note: This check is not truly necessary but it is good to
     * have it*/
    if(((P1IFG & 0x10) == 0x10) || ((P1IFG & 0x20) == 0x20)|| ((P1IFG & 0x02) == 0x02)){
        xSemaphoreGiveFromISR(xEvent_Button, &xHigherPriorityTaskWoken);
    }
    /*Clear IFG register on exit. Read more about it in offical MSP430F5529 documentation*/
    P1IFG &=~0x32;
    /* trigger scheduler if higher priority task is woken */
    portYIELD_FROM_ISR( xHigherPriorityTaskWoken );
}
